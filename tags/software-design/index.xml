<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Design on Kamran Sadin</title>
    <link>https://sadin.dev/tags/software-design/</link>
    <description>Recent content in Software Design on Kamran Sadin</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 26 Oct 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://sadin.dev/tags/software-design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dependency Inversion Principle</title>
      <link>https://sadin.dev/posts/2023-10-26-dependency-inversion-principle/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://sadin.dev/posts/2023-10-26-dependency-inversion-principle/</guid>
      <description>&lt;p&gt;In the realm of software design, fundamental principles serve as guiding lights for creating maintainable, flexible, and scalable codebases. One such crucial principle is the &lt;strong&gt;Dependency Inversion Principle (DIP)&lt;/strong&gt;. DIP is a fundamental component of the SOLID principles, initially introduced by Robert C. Martin. Understanding and applying the Dependency Inversion Principle is crucial for achieving decoupled and adaptable software systems.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/mastering-solid-principles-in-csharp/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/single-responsibility-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Single Responsibility Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/open-closed-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open/Closed Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/liskov-substitution-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Liskov Substitution Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/interface-segregation-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Interface Segregation Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/dependency-inversion-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Dependency Inversion Principle&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;what-is-the-dependency-inversion-principle&#34;&gt;&#xD;&#xA;  What is the Dependency Inversion Principle?&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#what-is-the-dependency-inversion-principle&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;The Dependency Inversion Principle emphasizes that high-level modules should not depend on low-level modules; both should depend on abstractions. Additionally, abstractions should not depend on details; instead, details should depend on abstractions. This principle encourages the use of interfaces or abstract classes to decouple higher-level and lower-level modules.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Interface Segregation Principle</title>
      <link>https://sadin.dev/posts/2023-10-24-interface-segregation-principle/</link>
      <pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://sadin.dev/posts/2023-10-24-interface-segregation-principle/</guid>
      <description>&lt;p&gt;In the realm of software design, fundamental principles serve as guiding lights for creating maintainable, flexible, and scalable codebases. One such crucial principle is the &lt;strong&gt;Interface Segregation Principle (ISP)&lt;/strong&gt;. ISP is a vital component of the SOLID principles, initially introduced by Robert C. Martin. Understanding and applying the Interface Segregation Principle is fundamental to achieving modular and cohesive software systems.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/mastering-solid-principles-in-csharp/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/single-responsibility-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Single Responsibility Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/open-closed-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open/Closed Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/liskov-substitution-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Liskov Substitution Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/interface-segregation-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Interface Segregation Principle&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/dependency-inversion-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dependency Inversion Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;what-is-the-interface-segregation-principle&#34;&gt;&#xD;&#xA;  What is the Interface Segregation Principle?&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#what-is-the-interface-segregation-principle&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;The Interface Segregation Principle advocates that clients should not be forced to depend on interfaces they do not use. In other words, a class should not be forced to implement methods it does not need. Instead of a monolithic interface, classes should have smaller, specific interfaces tailored to their requirements.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Liskov Substitution Principle</title>
      <link>https://sadin.dev/posts/2023-10-22-liskov-substitution-principle/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://sadin.dev/posts/2023-10-22-liskov-substitution-principle/</guid>
      <description>&lt;p&gt;In the realm of software design, adhering to fundamental principles is essential for creating maintainable, flexible, and scalable codebases. One such crucial principle is the &lt;strong&gt;Liskov Substitution Principle (LSP)&lt;/strong&gt;. LSP is a key element of the SOLID principles, initially introduced by Barbara Liskov. Understanding and applying the Liskov Substitution Principle is fundamental to achieving robust and extensible software systems.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/mastering-solid-principles-in-csharp/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/single-responsibility-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Single Responsibility Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/open-closed-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open/Closed Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/liskov-substitution-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Liskov Substitution Principle&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/interface-segregation-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Interface Segregation Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/dependency-inversion-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dependency Inversion Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;what-is-the-liskov-substitution-principle&#34;&gt;&#xD;&#xA;  What is the Liskov Substitution Principle?&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#what-is-the-liskov-substitution-principle&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;The Liskov Substitution Principle defines that objects of a derived class should be substitutable for objects of the base class without affecting the correctness of the program. In simpler terms, any instance of a base class should be replaceable with an instance of a derived class without altering the desired properties of the program.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Open Closed Principle</title>
      <link>https://sadin.dev/posts/2023-10-20-open-closed-principle/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://sadin.dev/posts/2023-10-20-open-closed-principle/</guid>
      <description>&lt;p&gt;In the realm of software design, certain principles serve as guiding lights for creating maintainable, flexible, and scalable codebases. One such foundational principle is the &lt;strong&gt;Open/Closed Principle (OCP)&lt;/strong&gt;. OCP is a crucial component of the SOLID principles, initially introduced by Bertrand Meyer. Understanding and applying the Open/Closed Principle can significantly impact software design.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/mastering-solid-principles-in-csharp/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/single-responsibility-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Single Responsibility Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/open-closed-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Open/Closed Principle&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/liskov-substitution-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Liskov Substitution Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/interface-segregation-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Interface Segregation Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/dependency-inversion-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dependency Inversion Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;what-is-the-openclosed-principle&#34;&gt;&#xD;&#xA;  What is the Open/Closed Principle?&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#what-is-the-openclosed-principle&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;The Open/Closed Principle emphasizes that software entities (classes, modules, functions, etc.) should be open for &lt;strong&gt;extension but closed for modification&lt;/strong&gt;. In simpler terms, the behavior of a module can be extended without modifying its source code. This principle promotes the creation of a system that is both adaptable and sustainable over time.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Single Responsibility Principle</title>
      <link>https://sadin.dev/posts/2023-10-18-single-responsibility-principle/</link>
      <pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://sadin.dev/posts/2023-10-18-single-responsibility-principle/</guid>
      <description>&lt;p&gt;In the realm of software development, adhering to well-established design principles is paramount for creating maintainable, flexible, and scalable codebases. One such foundational principle is the &lt;strong&gt;Single Responsibility Principle (SRP)&lt;/strong&gt;. SRP is one of the SOLID principles, initially introduced by Robert C. Martin, emphasizing a fundamental concept that profoundly influences software design.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/mastering-solid-principles-in-csharp/?&#34; &gt;Introduction&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/single-responsibility-principle/?&#34; &gt;&lt;strong&gt;Single Responsibility Principle&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/open-closed-principle/?&#34; &gt;Open/Closed Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/liskov-substitution-principle/?&#34; &gt;Liskov Substitution Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/interface-segregation-principle/?&#34; &gt;Interface Segregation Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/dependency-inversion-principle/?&#34; &gt;Dependency Inversion Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;what-is-the-single-responsibility-principle&#34;&gt;&#xD;&#xA;  What is the Single Responsibility Principle?&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#what-is-the-single-responsibility-principle&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;At its core, SRP advocates that a class should have a &lt;strong&gt;single reason to change&lt;/strong&gt;, meaning it should only have one responsibility. Essentially, a class should encapsulate one aspect of the functionality within the software. By adhering to this principle, the design becomes more modular, maintainable, and easier to extend.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mastering SOLID Principles in C#, Building Robust and Maintainable Applications</title>
      <link>https://sadin.dev/posts/2023-10-15-mastering-solid-principles-in-csharp/</link>
      <pubDate>Sun, 15 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://sadin.dev/posts/2023-10-15-mastering-solid-principles-in-csharp/</guid>
      <description>&lt;p&gt;In the realm of software development, crafting code that stands the test of time and remains flexible in the face of evolving requirements is an art. Enter the &lt;strong&gt;SOLID principles&lt;/strong&gt;, a set of guiding lights that illuminate the path toward building &lt;strong&gt;robust and maintainable applications&lt;/strong&gt;. Let&amp;rsquo;s delve into these principles, accompanied by C# examples, and explore how they transform real-world projects.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/mastering-solid-principles-in-csharp/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/single-responsibility-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Single Responsibility Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/open-closed-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open/Closed Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/liskov-substitution-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Liskov Substitution Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/interface-segregation-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Interface Segregation Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://sadin.dev/posts/dependency-inversion-principle/?&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dependency Inversion Principle&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;understanding-principles-in-software-design&#34;&gt;&#xD;&#xA;  Understanding Principles in Software Design&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#understanding-principles-in-software-design&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;In software design, a principle is a fundamental and foundational guideline that guides developers in creating software that is maintainable, scalable, and robust. Principles act as a set of recommended practices and rules that help in making design decisions throughout the software development lifecycle. They are based on experience, industry best practices, and lessons learned over time. These principles provide a higher-level understanding of how to structure code, organize components, and manage dependencies.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
